# 碳强度特征集成说明

## 📋 概述

本项目已成功集成碳强度特征，模仿 `ecmws-experiments` 项目处理电价的方式，将调度目标从最小化"能耗"扩展到最小化"碳成本"。

**核心定义**：
```
碳成本 = 能耗 × 碳强度
```

---

## 🎯 实现的功能

### 1. 碳强度数据管理

✅ **固定4个Host的碳强度曲线**
- 每个Host对应一个24小时碳强度曲线
- 数据结构：`list[list[float]]`，shape = (4个Host, 24小时)
- 位置：`scheduler/config/carbon_intensity.py`

✅ **碳强度数据来源**
- 参考 `ecmws-experiments/utils/given_data.py` 的电价数据结构
- 暂时使用相同的数值，可以后续手动修改为真实碳强度值

### 2. Host生成逻辑修改

✅ **强制生成4个Host**
- 修改 `generate_hosts()` 函数，忽略输入参数，始终生成4个Host
- 每个Host自动分配一个碳强度曲线
- 文件：`scheduler/dataset_generator/core/gen_vm.py`

### 3. 虚拟时钟管理系统

✅ **工作流级别的虚拟时钟**
- 每个工作流维护独立的虚拟时钟，从0:00开始
- 支持时钟推进和查询
- 文件：`scheduler/rl_model/core/env/clock_manager.py`

✅ **Workflow类扩展**
- 添加 `virtual_clock` 属性
- 提供 `advance_clock()` 和 `get_current_hour()` 方法
- 文件：`scheduler/dataset_generator/core/models.py`

### 4. VM特征扩展

✅ **VmDto扩展**
- 添加 `host_id`：Host的ID
- 添加 `host_carbon_intensity_curve`：Host的碳强度曲线
- 提供 `get_carbon_intensity_at()` 方法
- 文件：`scheduler/rl_model/core/types.py`

✅ **VmObservation扩展**
- 添加 `host_id` 和 `host_carbon_intensity_curve`
- 提供 `get_carbon_intensity_at()` 方法
- 文件：`scheduler/rl_model/core/env/observation.py`

### 5. GNN特征集成

✅ **VM节点特征扩展**
- 原有特征：`[完成时间, 速度倒数, 能耗率]`
- 新特征：`[完成时间, 速度倒数, 能耗率, 碳强度]`
- 文件：`scheduler/rl_model/agents/gin_agent/agent.py`

✅ **特征映射更新**
- 更新 `GinAgentMapper` 的 map/unmap 方法
- 更新 `GinAgentObsTensor` 数据类
- 文件：`scheduler/rl_model/agents/gin_agent/mapper.py`

✅ **特征提取**
- 在 `map_observation()` 中提取碳强度特征
- 使用VM完成时间对应的碳强度值
- 文件：`scheduler/rl_model/agents/gin_agent/wrapper.py`

### 6. 碳成本计算接口

✅ **EnvObservation.carbon_cost()**
- 计算总碳成本：`∑(能耗 × 碳强度)`
- 为奖励函数预留的接口
- 文件：`scheduler/rl_model/core/env/observation.py`

---

## 🔧 使用方法

### 1. 获取碳强度数据

```python
from scheduler.config.carbon_intensity import (
    CARBON_INTENSITY_DATA,
    get_carbon_intensity_at_time,
    calculate_carbon_cost
)

# 获取Host 0在第10小时的碳强度
carbon_intensity = get_carbon_intensity_at_time(host_id=0, time_seconds=10*3600)

# 计算碳成本
carbon_cost = calculate_carbon_cost(
    energy_consumption=1000.0,  # 能耗
    host_id=0,                  # Host ID
    start_time=0,               # 开始时间
    end_time=3600               # 结束时间
)
```

### 2. 使用碳成本接口

```python
from scheduler.rl_model.core.env.observation import EnvObservation

# 在环境中计算碳成本
obs = env.reset()
carbon_cost = obs.carbon_cost()  # 获取当前状态的总碳成本
```

### 3. 修改奖励函数（示例）

在 `scheduler/rl_model/agents/gin_agent/wrapper.py` 中修改 `step()` 方法：

```python
def step(self, action: int) -> tuple[np.ndarray, SupportsFloat, bool, bool, dict[str, Any]]:
    mapped_action = self.map_action(action)
    obs, _, terminated, truncated, info = super().step(mapped_action)
    assert isinstance(obs, EnvObservation)
    mapped_obs = self.map_observation(obs)

    # 计算多目标奖励
    makespan_reward = -(obs.makespan() - self.prev_obs.makespan()) / obs.makespan()
    energy_reward = -(obs.energy_consumption() - self.prev_obs.energy_consumption()) / obs.energy_consumption()
    
    # 新增：碳成本奖励
    carbon_cost = obs.carbon_cost()
    prev_carbon_cost = self.prev_obs.carbon_cost()
    carbon_reward = -(carbon_cost - prev_carbon_cost) / max(carbon_cost, 1e-8)
    
    # 综合奖励（权重可调整）
    reward = makespan_reward + energy_reward + carbon_reward

    self.prev_obs = obs
    return mapped_obs, reward, terminated, truncated, info
```

---

## 📊 数据结构

### 碳强度数据格式

```python
CARBON_INTENSITY_DATA = [
    # Host 0: 高碳强度区域（煤电为主）
    [0.15, 0.10, 0.11, 0.11, 0.19, 0.22, 0.19, 0.11, 0.12, 0.07, 0.08, 0.10, 0.14, ...],
    
    # Host 1: 低碳强度区域（水电/核电为主）
    [0.07, 0.08, 0.09, 0.07, 0.13, 0.14, 0.13, 0.13, 0.12, 0.12, 0.09, 0.09, 0.09, ...],
    
    # Host 2: 中等碳强度区域（混合能源）
    [0.10, 0.09, 0.11, 0.11, 0.09, 0.09, 0.10, 0.10, 0.15, 0.15, 0.15, 0.13, 0.12, ...],
    
    # Host 3: 高碳强度区域（天然气为主）
    [0.13, 0.13, 0.15, 0.15, 0.17, 0.19, 0.21, 0.21, 0.21, 0.18, 0.18, 0.17, 0.13, ...],
]
```

### 虚拟时钟机制

```python
# 批处理模式下的虚拟时钟
# 假设：所有工作流在调度开始时虚拟时钟都设为 0:00（凌晨0点）

workflow.virtual_clock = 0.0  # 初始化为0秒
workflow.advance_clock(3600)  # 推进1小时
current_hour = workflow.get_current_hour()  # 获取当前小时（0-23）
```

---

## 🔍 GNN特征空间变化

### 任务特征（4维）
- `task_state_scheduled`: 是否已调度
- `task_state_ready`: 是否就绪
- `task_length`: 任务计算量
- `task_normalized_deadline`: 归一化的子截止时间

### VM特征（4维 → 新增1维）
- `vm_completion_time`: VM完成时间
- `1 / vm_speed`: 速度倒数
- `vm_energy_rate`: 能耗率
- **`vm_carbon_intensity`**: 碳强度 ⭐ 新增

---

## 📝 修改文件清单

| 文件 | 修改内容 | 状态 |
|------|---------|------|
| `scheduler/config/carbon_intensity.py` | ✅ 新增：碳强度数据配置 | 完成 |
| `scheduler/dataset_generator/core/models.py` | ✅ Host添加carbon_intensity_curve<br>✅ Workflow添加virtual_clock | 完成 |
| `scheduler/dataset_generator/core/gen_vm.py` | ✅ 强制生成4个Host | 完成 |
| `scheduler/rl_model/core/types.py` | ✅ VmDto添加碳强度字段 | 完成 |
| `scheduler/rl_model/core/env/observation.py` | ✅ VmObservation添加碳强度<br>✅ 添加carbon_cost()方法 | 完成 |
| `scheduler/rl_model/core/env/clock_manager.py` | ✅ 新增：虚拟时钟管理器 | 完成 |
| `scheduler/rl_model/agents/gin_agent/mapper.py` | ✅ 添加碳强度到map/unmap | 完成 |
| `scheduler/rl_model/agents/gin_agent/agent.py` | ✅ VM特征添加碳强度维度 | 完成 |
| `scheduler/rl_model/agents/gin_agent/wrapper.py` | ✅ 提取碳强度特征 | 完成 |

---

## ⚠️ 注意事项

### 1. Host数量限制
- 项目现在强制生成4个Host
- 如果在 `generate_dataset()` 中设置 `host_count` 不为4，会输出警告但仍生成4个Host

### 2. 碳强度数据修改
如需修改碳强度数据，请编辑：
```
paper1115/scheduler/config/carbon_intensity.py
```

修改 `gen_carbon_intensity_data()` 函数中的数值：
```python
host1 = [0.15, 0.10, 0.11, ...]  # 修改这里的24个数值
host2 = [0.07, 0.08, 0.09, ...]
host3 = [0.10, 0.09, 0.11, ...]
host4 = [0.13, 0.13, 0.15, ...]
```

### 3. 奖励函数修改
当前**未修改**奖励函数，仍使用原有的 `makespan + energy`。

要添加碳成本，请修改 `wrapper.py` 的 `step()` 方法，参考上述示例代码。

### 4. 时间对齐
- 使用 `workflow.arrival_time` 作为绝对时间基准
- 任务的绝对时间 = `workflow.arrival_time + task.start_time`
- 碳强度根据任务执行时间动态计算

---

## 🧪 测试建议

### 基础功能测试

```python
# 测试碳强度特征是否正确加载
from scheduler.config.carbon_intensity import CARBON_INTENSITY_DATA, FIXED_NUM_HOSTS

print(f"Host数量: {FIXED_NUM_HOSTS}")
print(f"碳强度数据形状: {len(CARBON_INTENSITY_DATA)} x {len(CARBON_INTENSITY_DATA[0])}")

# 测试Host生成
from scheduler.dataset_generator.core.gen_dataset import generate_dataset

dataset = generate_dataset(
    seed=42,
    host_count=5,  # 会被忽略，强制生成4个
    vm_count=15,
    workflow_count=3,
    # ... 其他参数
)

print(f"实际生成的Host数量: {len(dataset.hosts)}")
for host in dataset.hosts:
    print(f"Host {host.id}: 碳强度曲线长度 = {len(host.carbon_intensity_curve)}")
```

### GNN特征测试

```python
# 测试GNN特征是否包含碳强度
env = CloudSchedulingGymEnvironment(dataset_args=...)
obs, info = env.reset()

# 检查VM观察中的碳强度
for vm_obs in obs.vm_observations:
    carbon_intensity = vm_obs.get_carbon_intensity_at(0)
    print(f"VM {vm_obs}: 碳强度 = {carbon_intensity}")
```

### 碳成本计算测试

```python
# 测试碳成本计算
env = CloudSchedulingGymEnvironment(dataset_args=...)
obs, info = env.reset()

# 执行几个步骤
for _ in range(10):
    action = env.action_space.sample()
    obs, reward, done, truncated, info = env.step(action)

# 计算碳成本
total_carbon_cost = obs.carbon_cost()
total_energy = obs.energy_consumption()
print(f"总能耗: {total_energy}")
print(f"总碳成本: {total_carbon_cost}")
```

---

## 🚀 下一步工作

### 待实现功能

1. **修改奖励函数**
   - 当前奖励函数仍为 `makespan + energy`
   - 需要添加碳成本组件：`+ carbon_reward`
   - 位置：`scheduler/rl_model/agents/gin_agent/wrapper.py`

2. **权重调优**
   - 确定 makespan、energy、carbon 三者的权重
   - 建议从 `[0.33, 0.33, 0.34]` 开始尝试

3. **训练验证**
   - 使用新特征重新训练模型
   - 验证模型是否能学会碳感知调度策略

---

## 📐 架构设计说明

### 时间管理方式

**批处理 + 虚拟时钟**：
- 所有工作流在调度开始时已知
- 每个工作流的虚拟时钟从0:00开始
- 随着任务分配，虚拟时钟推进
- 碳强度根据虚拟时钟时间动态计算

### 与ecmws的差异

| 特性 | ecmws | paper1115 |
|------|-------|----------|
| **调度模式** | 动态在线调度 | 离线批处理 |
| **时钟系统** | 全局时钟 | 工作流虚拟时钟 |
| **电价/碳强度** | 24维向量（4DC×6h） | 1维标量（当前时间） |
| **时间推进** | 时间槽推进 | 任务完成时推进 |

### 设计优势

1. **最小化架构改动**：利用现有的批处理框架
2. **简单直接**：虚拟时钟管理简单明了
3. **易于扩展**：为奖励函数预留了清晰的接口
4. **兼容性好**：不影响现有功能

---

## 💡 关键接口说明

### 1. 获取VM的碳强度

```python
# 方法1：通过VmObservation
vm_obs: VmObservation = obs.vm_observations[vm_id]
carbon_intensity = vm_obs.get_carbon_intensity_at(time_seconds)

# 方法2：通过VmDto
vm_dto: VmDto = state.static_state.vms[vm_id]
carbon_intensity = vm_dto.get_carbon_intensity_at(time_seconds)

# 方法3：直接访问数组
carbon_intensity = vm_dto.host_carbon_intensity_curve[hour]
```

### 2. 计算碳成本

```python
# 方法1：使用预留接口（推荐）
carbon_cost = obs.carbon_cost()

# 方法2：手动计算
carbon_cost = 0.0
for task_obs in obs.task_observations:
    if task_obs.assigned_vm_id is not None:
        vm_obs = obs.vm_observations[task_obs.assigned_vm_id]
        carbon_intensity = vm_obs.get_carbon_intensity_at(task_obs.start_time)
        carbon_cost += task_obs.energy_consumption * carbon_intensity
```

### 3. 工作流时钟管理

```python
# 初始化时钟管理器
clock_manager = ClockManager()
clock_manager.initialize(workflows)

# 获取工作流时钟
current_time = clock_manager.get_workflow_clock(workflow_id)

# 推进时钟
clock_manager.update_clock_for_task_completion(task_id, completion_time)
```

---

## 📊 特征验证

运行以下代码验证特征是否正确集成：

```python
from scheduler.dataset_generator.core.gen_dataset import generate_dataset
from scheduler.rl_model.core.env.gym_env import CloudSchedulingGymEnvironment
from scheduler.rl_model.agents.gin_agent.wrapper import GinAgentWrapper

# 生成数据集
dataset = generate_dataset(
    seed=42,
    host_count=4,
    vm_count=15,
    workflow_count=3,
    dag_method='pegasus',
    task_length_dist='uniform',
    min_task_length=10000,
    max_task_length=100000,
    task_arrival='static',
    arrival_rate=1.0,
)

# 创建环境
env = CloudSchedulingGymEnvironment(dataset=dataset)
wrapped_env = GinAgentWrapper(env)

# 重置并检查
obs, info = wrapped_env.reset()
print(f"观察空间形状: {obs.shape}")

# 执行步骤
action = wrapped_env.action_space.sample()
obs, reward, done, truncated, info = wrapped_env.step(action)
print(f"奖励: {reward}")
```

---

## ✅ 完成状态

- [x] 碳强度数据配置
- [x] Host生成逻辑修改
- [x] 虚拟时钟管理
- [x] VM特征扩展
- [x] GNN特征集成
- [x] 碳成本计算接口
- [ ] 奖励函数修改（待后续实现）

---

## 📚 相关文件索引

- **配置文件**：`scheduler/config/carbon_intensity.py`
- **数据模型**：`scheduler/dataset_generator/core/models.py`
- **VM生成**：`scheduler/dataset_generator/core/gen_vm.py`
- **时钟管理**：`scheduler/rl_model/core/env/clock_manager.py`
- **类型定义**：`scheduler/rl_model/core/types.py`
- **观察空间**：`scheduler/rl_model/core/env/observation.py`
- **GNN代理**：`scheduler/rl_model/agents/gin_agent/`

