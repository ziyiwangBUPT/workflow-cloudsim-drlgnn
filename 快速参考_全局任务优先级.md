# 快速参考：全局任务优先级

## 🎯 核心改动

### 1. 新增字段

**Workflow**：
```python
workflow.workflow_priority  # 工作流优先级分数（越小越高）
```

**Task**：
```python
task.global_priority  # 全局任务优先级 = workflow_priority × rank_dp
```

---

## 📖 使用示例

### 示例1：获取工作流优先级

```python
from scheduler.dataset_generator.core.gen_dataset import generate_dataset
from scheduler.pre_scheduling.pre_computation import precompute_workflow_data
from scheduler.pre_scheduling.ws_method import ContentionAwareWorkflowSequencing

# 生成数据集
dataset = generate_dataset(...)

# 预计算
for workflow in dataset.workflows:
    precompute_workflow_data(workflow, dataset.vms, rho=0.2)

# 计算工作流优先级（不排序）
ws_scheduler = ContentionAwareWorkflowSequencing(0.33, 0.33, 0.33)
ws_scheduler.run(dataset.workflows, dataset.vms)

# 访问优先级
for workflow in dataset.workflows:
    print(f"工作流 {workflow.id}: priority={workflow.workflow_priority:.4f}")
```

---

### 示例2：动作空间剪裁

```python
# 在环境中，获取所有就绪任务
ready_tasks = []
for task_id, task_state in enumerate(env.state.task_states):
    if task_state.is_ready and task_state.assigned_vm_id is None:
        task = env.state.static_state.tasks[task_id]
        ready_tasks.append((task_id, task.global_priority))

# 按全局优先级排序（越小优先级越高）
ready_tasks.sort(key=lambda x: x[1])

# 选择优先级最高的前K个任务
K = 5
top_k_tasks = ready_tasks[:K]

# 从这K个任务中随机选择
import random
selected_task_id, _ = random.choice(top_k_tasks)

# 执行调度动作
action = EnvAction(task_id=selected_task_id, vm_id=selected_vm_id)
obs, reward, done, truncated, info = env.step(action)
```

---

### 示例3：优先级可视化

```python
import matplotlib.pyplot as plt

# 收集所有任务的优先级
all_priorities = []
for workflow in dataset.workflows:
    for task in workflow.tasks:
        all_priorities.append({
            'workflow_id': workflow.id,
            'task_id': task.id,
            'workflow_priority': workflow.workflow_priority,
            'rank_dp': task.rank_dp,
            'global_priority': task.global_priority
        })

# 绘制全局优先级分布
priorities = [p['global_priority'] for p in all_priorities]
plt.hist(priorities, bins=50)
plt.xlabel('Global Priority')
plt.ylabel('Count')
plt.title('Task Global Priority Distribution')
plt.show()
```

---

### 示例4：按优先级排序任务

```python
# 获取所有任务并按全局优先级排序
all_tasks = []
for workflow in dataset.workflows:
    for task in workflow.tasks:
        all_tasks.append(task)

# 排序（优先级越小越高）
all_tasks.sort(key=lambda t: t.global_priority)

# 输出前10个最高优先级任务
print("Top 10 highest priority tasks:")
for i, task in enumerate(all_tasks[:10]):
    print(f"{i+1}. Task {task.id} (workflow {task.workflow_id}): "
          f"global_priority={task.global_priority:.4f}")
```

---

## 🔍 优先级计算详解

### workflow_priority（工作流优先级）

**公式**：
```
workflow_priority = α₁ × (st/max_st) + α₂ × (wl/max_wl) + α₃ × (ct/max_ct)
```

**组成**：
- `st`: 松弛时间 = deadline - avg_eft
- `wl`: 工作负载 = Σ task.length
- `ct`: 竞争度 = 最大并发任务数

**默认权重**：α₁=0.33, α₂=0.33, α₃=0.33

**语义**：值越小，工作流优先级越高

---

### rank_dp（任务优先级）

**公式**：
```
rank_dp[task] = max(rank_dp[child]) + avg_worktime[task]
```

**语义**：
- 表示从该任务到出口任务的最长执行路径
- 值越大，任务优先级越高

---

### global_priority（全局任务优先级）

**公式**：
```
global_priority = workflow_priority × rank_dp
```

**语义**：
- 综合考虑工作流和任务两个层面的优先级
- 值越小，整体优先级越高
- 用于在所有工作流的任务中比较相对优先级

---

## ⚠️ 重要提示

### 优先级方向

```python
# workflow_priority: 越小越高
if wf1.workflow_priority < wf2.workflow_priority:
    print("wf1 优先级更高")

# rank_dp: 越大越高
if task1.rank_dp > task2.rank_dp:
    print("task1 优先级更高（在同一工作流内）")

# global_priority: 越小越高
if task1.global_priority < task2.global_priority:
    print("task1 全局优先级更高")
```

### 排序方式

```python
# 按工作流优先级排序（升序）
workflows.sort(key=lambda wf: wf.workflow_priority)

# 按任务全局优先级排序（升序）
tasks.sort(key=lambda t: t.global_priority)
```

---

## 🚀 常见应用场景

### 1. Top-K任务选择

```python
def select_top_k_tasks(env, K=5):
    """选择优先级最高的K个就绪任务"""
    ready_tasks = [
        (task_id, env.state.static_state.tasks[task_id].global_priority)
        for task_id, task_state in enumerate(env.state.task_states)
        if task_state.is_ready and task_state.assigned_vm_id is None
    ]
    ready_tasks.sort(key=lambda x: x[1])
    return [task_id for task_id, _ in ready_tasks[:K]]
```

### 2. 优先级感知的奖励函数

```python
def compute_reward(obs, prev_obs):
    # 原有奖励
    makespan_reward = -(obs.makespan() - prev_obs.makespan())
    energy_reward = -(obs.energy_consumption() - prev_obs.energy_consumption())
    
    # 新增：优先级奖励
    # 优先完成高优先级任务给予额外奖励
    priority_reward = 0
    for task_obs in obs.task_observations:
        if task_obs.assigned_vm_id is not None:
            # global_priority越小奖励越大
            priority_reward += 1.0 / (task_obs.global_priority + 1e-6)
    
    return makespan_reward + energy_reward + 0.1 * priority_reward
```

### 3. 智能动作屏蔽

```python
def get_valid_actions(env, percentile=90):
    """只保留高优先级任务的动作"""
    ready_tasks = [
        (task_id, env.state.static_state.tasks[task_id].global_priority)
        for task_id, task_state in enumerate(env.state.task_states)
        if task_state.is_ready and task_state.assigned_vm_id is None
    ]
    
    if not ready_tasks:
        return []
    
    # 计算优先级阈值（第90百分位）
    priorities = [p for _, p in ready_tasks]
    threshold = np.percentile(priorities, percentile)
    
    # 只保留优先级高于阈值的任务
    high_priority_tasks = [
        task_id for task_id, priority in ready_tasks
        if priority <= threshold  # 注意：越小越高
    ]
    
    return high_priority_tasks
```

---

## 📊 验证方法

运行测试脚本：

```bash
cd paper1115
python test_priority_refactor.py
```

预期输出：
```
✅ 通过: WS算法不排序
✅ 通过: 全局任务优先级计算
✅ 通过: workflow_id一致性
```

---

## 📝 相关文档

- `工作流优先级重构总结.md` - 完整的重构说明
- `预调度功能实现总结.md` - 预调度算法详解
- `rank_dp和deadline详解.md` - rank_dp的详细说明

---

**更新日期**: 2025-10-26

