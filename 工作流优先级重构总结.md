# 工作流优先级重构总结

## 🎯 重构目标

解决工作流排序导致的workflow_id混乱问题，并添加全局任务优先级支持。

---

## ✅ 完成的修改

### 1. 数据模型扩展

**`scheduler/dataset_generator/core/models.py`**

#### Workflow类新增字段：
```python
workflow_priority: float = 0.0  # 工作流优先级分数（WS算法计算，值越小优先级越高）
```

#### Task类新增字段：
```python
global_priority: float = 0.0  # 全局优先级分数（工作流优先级 × 任务优先级）
```

修改说明：
- `rank_dp` 的注释从"DP排名"改为"任务内优先级分数"
- `global_priority` 用于在所有工作流的任务中比较相对优先级

---

### 2. WS算法修改 - 只计算分数不排序

**`scheduler/pre_scheduling/ws_method.py`**

#### 修改前：
```python
def run(self, workflows, vms) -> List[Workflow]:
    # ... 计算优先级分数 ...
    ranks = [(wf, score) for wf, score in ...]
    ranks.sort(key=lambda x: x[1])  # 排序
    return [wf for wf, _ in ranks]   # 返回排序后的列表
```

#### 修改后：
```python
def run(self, workflows, vms) -> List[Workflow]:
    # ... 计算优先级分数 ...
    for wf, st, wl, ct in zip(workflows, st_lst, wl_lst, ct_lst):
        wf.workflow_priority = self.a1 * st / max_st + self.a2 * wl / max_wl + self.a3 * ct / max_ct
    return workflows  # 返回原始列表（不排序）
```

**关键改变**：
- ❌ 不再对工作流列表进行排序
- ✅ 直接将优先级分数写入 `workflow.workflow_priority`
- ✅ 返回原始列表

---

### 3. gym_env.py 重构

**`scheduler/rl_model/core/env/gym_env.py`**

#### 修改1：预调度阶段

```python
# 之前
sorted_workflows = ws_scheduler.run(dataset.workflows, dataset.vms)
for workflow in sorted_workflows:
    dp_scheduler.run(workflow, dataset.vms)

# 重新分配workflow_id（已删除）
for new_wf_id, workflow in enumerate(sorted_workflows):
    workflow.id = new_wf_id
    for task in workflow.tasks:
        task.workflow_id = new_wf_id

dataset.workflows = sorted_workflows
```

```python
# 现在
ws_scheduler.run(dataset.workflows, dataset.vms)  # 不再排序
for workflow in dataset.workflows:
    dp_scheduler.run(workflow, dataset.vms)

# 计算全局任务优先级
for workflow in dataset.workflows:
    for task in workflow.tasks:
        task.global_priority = workflow.workflow_priority * task.rank_dp

# 不再重新分配workflow_id
```

**关键改变**：
- ❌ 删除了workflow_id重新分配逻辑
- ✅ 保持原始workflow_id不变
- ✅ 添加了全局任务优先级计算

#### 修改2：时钟初始化（简化）

```python
# 现在更简单（因为不需要处理ID重新分配）
clock_manager = ClockManager()
clock_manager.workflow_clocks.clear()
clock_manager.task_to_workflow.clear()

# 为每个工作流创建时钟
from scheduler.rl_model.core.env.clock_manager import WorkflowClock
for workflow in dataset.workflows:
    clock_manager.workflow_clocks[workflow.id] = WorkflowClock(workflow_id=workflow.id)

# 建立mapped_task_id -> workflow_id的映射
for mapped_task_id in range(len(mapped_tasks)):
    try:
        if mapped_task_id == 0 or mapped_task_id == len(mapped_tasks) - 1:
            continue
        workflow_id, _ = task_mapper.unmap_id(mapped_task_id)
        clock_manager.task_to_workflow[mapped_task_id] = workflow_id
    except:
        pass
```

**关键改变**：
- ✅ 由于不再重新分配ID，映射逻辑更直接
- ✅ 直接使用workflow.id而不需要担心ID不连续

---

## 📊 测试结果

运行 `python test_priority_refactor.py`：

```
✅ 通过: WS算法不排序
✅ 通过: 全局任务优先级计算
✅ 通过: workflow_id一致性
```

### 测试1: WS算法不排序

```
原始工作流ID: [0, 1, 2, 3, 4]
WS后工作流ID: [0, 1, 2, 3, 4]  ✅ 顺序保持不变

工作流优先级分数:
  工作流 0: workflow_priority=0.7893
  工作流 1: workflow_priority=0.7894
  工作流 2: workflow_priority=0.7237
  工作流 3: workflow_priority=0.8997
  工作流 4: workflow_priority=0.9240
```

### 测试2: 全局任务优先级计算

```
工作流 0 (workflow_priority=0.9894):
  任务 0: rank_dp=119.94, global_priority=118.67
  任务 1: rank_dp=40.12, global_priority=39.70

工作流 1 (workflow_priority=0.7265):
  任务 0: rank_dp=79.05, global_priority=57.43
  任务 1: rank_dp=64.14, global_priority=46.60
```

**验证**：`global_priority = workflow_priority × rank_dp` ✅

### 测试4: workflow_id一致性

```
原始workflow ID: [0, 1, 2, 3]
预调度后workflow ID: [0, 1, 2, 3]  ✅ 完全一致
✅ 所有任务的workflow_id与其工作流一致
```

---

## 🎯 重构效果

### 解决的问题

1. ✅ **workflow_id不再混乱**
   - 不再排序工作流
   - 不再重新分配ID
   - ID保持数据生成时的原始值

2. ✅ **全局任务优先级支持**
   - 添加了 `task.global_priority` 字段
   - 计算公式：`workflow_priority × rank_dp`
   - 可用于动作空间剪裁

3. ✅ **时钟管理简化**
   - 不需要处理ID重新分配
   - 映射逻辑更直接
   - 更容易理解和维护

4. ✅ **代码更简洁**
   - 删除了不必要的排序逻辑
   - 删除了ID重新分配逻辑
   - 减少了复杂度

---

## 📝 使用说明

### 访问工作流优先级

```python
for workflow in dataset.workflows:
    print(f"工作流 {workflow.id}: priority={workflow.workflow_priority}")
    # workflow_priority 越小，优先级越高
```

### 访问全局任务优先级

```python
for workflow in dataset.workflows:
    for task in workflow.tasks:
        print(f"任务 {task.id}: global_priority={task.global_priority}")
        # global_priority = workflow_priority × rank_dp
```

### 动作空间剪裁示例

```python
# 获取当前可调度的所有任务
ready_tasks = [
    task for task in all_tasks 
    if task.is_ready and task.assigned_vm_id is None
]

# 按全局优先级排序（优先级越小越高）
ready_tasks.sort(key=lambda t: t.global_priority)

# 选择优先级最高的前K个任务
top_k_tasks = ready_tasks[:K]

# 从这K个任务中随机选择
selected_task = random.choice(top_k_tasks)
```

---

## 🔍 优先级语义

### workflow_priority（工作流优先级）

**计算公式**：
```
workflow_priority = α₁ × (st/max_st) + α₂ × (wl/max_wl) + α₃ × (ct/max_ct)
```

其中：
- `st`: 松弛时间（deadline - avg_eft）
- `wl`: 工作负载（所有任务长度之和）
- `ct`: 竞争度（最大并发任务数）

**语义**：值越小，优先级越高

### rank_dp（任务优先级）

**计算公式**：
```
rank_dp = max(rank_dp[child]) + avg_worktime[task]
```

**语义**：
- 表示从该任务到出口任务的最长执行路径
- 值越大，对完成时间影响越大，优先级越高

### global_priority（全局任务优先级）

**计算公式**：
```
global_priority = workflow_priority × rank_dp
```

**语义**：
- 综合考虑工作流优先级和任务优先级
- 值越小，整体优先级越高
- 可用于在所有工作流的任务中比较相对优先级

**注意**：由于 `workflow_priority` 越小优先级越高，`rank_dp` 越大优先级越高，所以 `global_priority` 越小整体优先级越高。

---

## ⚠️ 注意事项

1. **优先级方向**：
   - `workflow_priority`: 越小越高
   - `rank_dp`: 越大越高
   - `global_priority`: 越小越高

2. **时钟管理**：
   - 虽然简化了初始化，但仍需要使用mapped_task_id进行映射
   - 这是因为环境中使用的是TaskMapper映射后的ID

3. **向后兼容**：
   - 如果有其他代码依赖WS算法的排序结果，需要单独处理
   - 当前修改不影响预调度算法的计算结果

---

## 🚀 后续工作

1. **动作空间剪裁实现**：
   - 使用 `global_priority` 选择top-K任务
   - 减少动作空间大小
   - 提高训练效率

2. **奖励函数优化**：
   - 可以考虑将优先级纳入奖励计算
   - 优先完成高优先级任务

3. **可视化支持**：
   - 绘制工作流优先级分布
   - 绘制全局任务优先级热图

---

## 📅 重构日期

2025-10-26

## 👤 开发者

AI Assistant (Claude Sonnet 4.5)

---

**状态**：✅ 重构完成并测试通过

