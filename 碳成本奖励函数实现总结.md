# 碳成本奖励函数实现总结

## 📋 概述

成功将强化学习奖励函数从 **makespan + 能耗** 改为 **makespan + 碳成本**，实现了碳排放感知的工作流调度。

## 🎯 设计思路

### 核心理念

用户的分析完全正确：
1. **不需要额外的虚拟时钟系统** - VM 的 `completion_time` 本身就是时间指针
2. **时间已经在 step 中计算** - 任务的 `start_time` 和 `completion_time` 已存在
3. **直接查询碳强度曲线** - 使用时间段查询主机的碳强度变化

### 关键公式

```
碳成本(gCO2) = 能耗(kWh) × 平均碳强度(gCO2/kWh)

其中：
- 能耗(kWh) = 能耗(Joules) / 3,600,000
- 平均碳强度 = Σ(时段碳强度 × 时段时长) / 总时长
```

## 📝 实现细节

### 1. 时间段平均碳强度计算

**文件**: `scheduler/config/carbon_intensity.py`

新增函数 `get_average_carbon_intensity(host_id, start_time, end_time)`:
- 如果任务在一个小时内完成，使用开始时间的碳强度
- 如果跨越多个小时，计算时间加权平均碳强度
- 处理跨越24小时的循环情况

```python
def get_average_carbon_intensity(host_id: int, start_time: float, end_time: float) -> float:
    """计算时间段的平均碳强度（时间加权平均）"""
    # 详见实现...
```

### 2. 碳成本计算函数

**文件**: `scheduler/config/carbon_intensity.py`

更新函数 `calculate_carbon_cost(energy_joules, host_id, start_time, end_time)`:
- 输入：能耗（Joules）、主机ID、开始/结束时间
- 单位转换：Joules → kWh
- 输出：碳成本（gCO2）

```python
def calculate_carbon_cost(energy_joules: float, host_id: int, 
                          start_time: float, end_time: float) -> float:
    energy_kwh = energy_joules / 3_600_000.0
    avg_carbon_intensity = get_average_carbon_intensity(host_id, start_time, end_time)
    return energy_kwh * avg_carbon_intensity
```

### 3. TaskState 扩展

**文件**: `scheduler/rl_model/core/env/state.py`

新增字段:
```python
@dataclass
class TaskState:
    # ... 原有字段 ...
    carbon_cost: float = 0  # 新增：任务的碳成本（gCO2）
```

### 4. Step 中计算碳成本

**文件**: `scheduler/rl_model/core/env/gym_env.py`

在 `step()` 方法中，计算能耗后立即计算碳成本:
```python
# Update energy consumption
new_task_states[action.task_id].energy_consumption = (
    active_energy_consumption_per_mi(self.state.static_state.vms[action.vm_id])
    * self.state.static_state.tasks[action.task_id].length
)

# Update carbon cost
from scheduler.config.carbon_intensity import calculate_carbon_cost
vm = self.state.static_state.vms[action.vm_id]
new_task_states[action.task_id].carbon_cost = calculate_carbon_cost(
    energy_joules=new_task_states[action.task_id].energy_consumption,
    host_id=vm.host_id,
    start_time=new_task_states[action.task_id].start_time,
    end_time=new_task_states[action.task_id].completion_time
)
```

### 5. EnvObservation 更新

**文件**: `scheduler/rl_model/core/env/observation.py`

- `TaskObservation` 新增 `carbon_cost` 字段
- `EnvObservation.__init__` 传递碳成本
- `EnvObservation.carbon_cost()` 累加所有已调度任务的碳成本

```python
def carbon_cost(self) -> float:
    """计算总碳成本（直接累加各任务的碳成本）"""
    total_carbon_cost = 0.0
    for task_obs in self.task_observations:
        if task_obs.assigned_vm_id is not None:
            total_carbon_cost += task_obs.carbon_cost
    return total_carbon_cost
```

### 6. 奖励函数修改

**文件**: `scheduler/rl_model/agents/gin_agent/wrapper.py`

将能耗奖励替换为碳成本奖励:
```python
def step(self, action: int):
    # ... 执行动作 ...
    
    # 奖励函数：makespan + 碳成本
    makespan_reward = -(obs.makespan() - self.prev_obs.makespan()) / obs.makespan()
    
    # 碳成本奖励（替换原来的能耗奖励）
    current_carbon = obs.carbon_cost()
    prev_carbon = self.prev_obs.carbon_cost()
    
    if current_carbon > 0:
        carbon_reward = -(current_carbon - prev_carbon) / current_carbon
    else:
        carbon_reward = 0.0
    
    reward = makespan_reward + carbon_reward
    # ...
```

## ✅ 测试验证

### 单元测试

**文件**: `test_carbon_cost_unit.py`

所有测试通过：
- ✓ 碳强度数据配置（4个Host × 24小时）
- ✓ 时间点碳强度查询（取模24小时）
- ✓ 平均碳强度计算（时间加权平均）
- ✓ 碳成本计算（Joules → kWh, 单位转换）
- ✓ 边界情况处理（0时长、循环、极小值）

### 集成测试

**文件**: `test_carbon_reward.py`（需要安装 gymnasium）

测试内容：
- Step 中的碳成本自动计算
- 奖励函数的碳成本组件
- 完整训练流程

## 📊 数据流

```
1. 环境 reset
   └─> 生成 Dataset（4个Host，每个有24小时碳强度曲线）

2. 环境 step(action)
   ├─> 计算任务开始时间（max(父任务完成时间, VM完成时间)）
   ├─> 计算任务结束时间（开始时间 + 执行时间）
   ├─> 计算能耗（能耗率 × 任务长度）
   ├─> 计算碳成本：
   │   ├─> 获取平均碳强度（host_id, start_time, end_time）
   │   ├─> 转换能耗单位（Joules → kWh）
   │   └─> 碳成本 = 能耗 × 碳强度
   └─> 保存到 TaskState.carbon_cost

3. 奖励计算
   ├─> 获取总碳成本（累加所有已调度任务）
   ├─> 计算碳成本增量
   └─> 归一化：-(增量 / 当前值)
```

## 🎉 关键优势

### 1. 简洁高效
- **不需要额外时钟系统** - 复用已有的 VM completion_time
- **单次计算，多次复用** - 碳成本在 step 中计算并保存

### 2. 精确计算
- **时间加权平均** - 准确反映任务跨越多小时的碳强度变化
- **单位转换正确** - Joules → kWh → gCO2

### 3. 易于扩展
- **接口清晰** - 碳成本计算独立于奖励函数
- **可调整权重** - 可以轻松调整 makespan 和碳成本的权重

## 📌 关键要点

1. **时间绑定在 VM 端** - 每个 VM 的 `completion_time` 就是时间指针，不需要额外的工作流时钟

2. **碳强度查询基于主机** - 每个 VM 绑定一个 Host，Host 有自己的碳强度曲线

3. **单位换算至关重要**:
   - 能耗：Joules (来自 `active_energy_consumption_per_mi`)
   - 碳强度：gCO2/kWh (配置数据)
   - 1 kWh = 3,600,000 Joules

4. **奖励归一化** - 使用增量除以当前值，保证奖励信号稳定

## 🚀 后续工作

可选的改进方向：

1. **多目标权重调整** - 实验不同的 makespan 和碳成本权重比例
2. **碳强度数据** - 使用真实数据中心的碳强度曲线
3. **动态碳强度** - 考虑季节、天气等因素的影响
4. **Pareto 前沿分析** - 分析 makespan 和碳成本的权衡关系

## 📁 修改文件清单

1. ✅ `scheduler/config/carbon_intensity.py` - 添加平均碳强度和碳成本计算
2. ✅ `scheduler/rl_model/core/env/state.py` - TaskState 添加 carbon_cost 字段
3. ✅ `scheduler/rl_model/core/env/gym_env.py` - step 中计算碳成本
4. ✅ `scheduler/rl_model/core/env/observation.py` - 传递和累加碳成本
5. ✅ `scheduler/rl_model/agents/gin_agent/wrapper.py` - 奖励函数使用碳成本
6. ✅ `test_carbon_cost_unit.py` - 单元测试
7. ✅ `test_carbon_reward.py` - 集成测试

## 💡 使用建议

### 安装依赖

如果要运行完整测试，需要安装：
```bash
pip install gymnasium==0.28.1
```

### 运行测试

```bash
# 碳成本计算单元测试（不需要 gymnasium）
python test_carbon_cost_unit.py

# 完整集成测试（需要 gymnasium）
python test_carbon_reward.py
```

### 训练模型

现在可以直接使用现有的训练脚本，奖励函数会自动使用碳成本：
```bash
python train.py  # 或你的训练脚本
```

---

**实现时间**: 2025年10月28日  
**实现状态**: ✅ 完成并测试通过

